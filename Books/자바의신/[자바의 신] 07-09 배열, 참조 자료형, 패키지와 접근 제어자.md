# 7장 배열

**배열**

- 한 타입에 대해 하나의 변수에 여러 개의 데이터 넣을 수 있다.
- 기본 자료형 배열의 기본값은 각 자료형의 기본값과 동일하다
- 참조 자료형은 초기화를 하지 않으면 “null” 값을 갖는다.
- 모든 배열은 참조 자료형인다. 이것을 그냥 출력하면,  `[Ljava.lang.Strubg;@1540e19d`

**절대 변경되지 않는 값이 있는 배열 선언**

→ 배열을 메소드 안이 아니라 외부에 static으로 선언하면 좋음 . static이 없다면 ArrayInit이라는 클래스 객체를 생성할 때 마다 배열 변수가 생성되는데, 이런 단점을 static이 해결해준다.

```java
public class ArrayInit {
	static String [] month = { "J", "F", "M" };
	
	public String getMonth(int m){
	}
}
```

**2차원 배열**

- 2차원 이상의 배열은 사용하지 않을 것

- 배열의 공간의 크기 서로 다르게 하기

  이때, **배열 크기를 알아내는 변수를 할당하여 사용하는 것**이 .length를 for 루프가 수행될 때 마다 길이 얻어오는 것보다 훨씬 효과적

  ```java
  int aLen = aDim.length;
  for(int i=0; i<aLen; i++) {
  	int bLen = bDim.length;
  	for(int j=0; j<bLen; j++) {
  		// blar
  	}
  }
  ```

**배열을 위한 for 루프**

- 배열의 값만들 가져올 때 이것이 편리하지만, 위치를 알아야 할 때는 임시 변수를 따로 둬야 함

```java
for(타입이름 임시변수명 : 반복대상객체){
} 

int aCnt = 0;
for (int[] aD : aDim){
	int bCnt = 0;
	for (int d : aD){
		bCnt++;
	}
	aCnt++;
}
```

### 요약

1. 배열을 선언할 때 boolean 배열의 크기만 지정했다면 배열의 [0] 위치에 있는 값은 무엇인가요?

- false

1. ArrayIndexOutOfBoundsException 이라는 것은 언제 발생하는가?

- 배열의 크기를 벗어나는 index에 접근할 때

1. 자바 프로그램이 시작할 때 전달 받는 내용은 어떤 타입?

- string

# 8장 참조 자료형

**참조 자료형**

- new를 통해서 객체를 생성하면 참조 자료형(그게 아니면 기본 자료형)
- new 없이도 객체를 생성할 수 있는 참조 자료형은 오직 String 뿐
- - 는 오직 String 에서만

**기본 생성자**

- 기본 생성자는 다른 생성자 없을 경우 기본으로 만들어진다
- 메소드와 비슷하게 생겼고, 리턴 타입 없고 클래스 이름으로 되어 있음
- 생성자가 필요한 이유는 **객체를 생성하기 위해서**이며, 리턴 타입이 없는 이유는 **생성자의 리턴 타입은 클래스의 객체**이기 때문이다.. 그래서 **클래스와 이름이 같아야 생성자인지 컴파일러가 알 수 있음**

**this 예약어**

- `이 객체`라는 의미
- `this.인스턴스 변수 이름 = 매개 변수 이름`
- 매개변수가 없는 생성자 제외하고 this 사용
- **객체의 변수와 매개변수의 이름이 동일할 때, 인스턴스의 변수를 구분하기 위해서 사용**

```java
public class MemberDTO {
	public String name;
	public String phone;
	public String email;
	public MemberDTO() {
	}
	public MemberDTO(String name) {
		this.name =name;
	}
}
```

**메소드의 오버로딩(Overloading)**

- **이름은 동일하지만, 매개변수의 종류, 개수, 순서가 다르도록** 하는 기술
- 기본적으로 **같은 역할을 하는 메소드들은 같은 이름을 가지게 함**으로써 → 매개변수에 따라서 메소드이름이 바뀐다면 코드 짜는게 어렵기 때문에 필요함

**return**

- 메소드가 종료되는 조건
  - 메소드의 모든 문장이 실행되었을 때
  - return 문장에 도달했을 때
  - 예외가 발생했을 때
- 여러 개를 넘겨 줄 수 없다면, DTO 같은 리턴 타입으로 선언하여 넘겨줌

**static 메소드와 일반 메소드 차이**

- static 메소드는 객체 생성하지 않고도 메소드 호출 가능
- static 메소드는 클래스 변수만 사용 가능 → 클래스 변수가 된다는 것은 모든 객체에서 하나의 값을 바라본다는 의미다.

static 블록

- 객체는 여러 개를 생성하지만, 한 번만 호출되어야 하는 코드가 있다면 static 적용
- **객체가 생성되기 전에  1) 한 번만 호출되고,** 2) 클래스 내에 선언되어야, 3) 메소드 내에서는 선언할 수 없다.
- 객체를 생성해서 객체 생성 전과 후에 출력해보면, 생성자가 호출되기 전에 static 블록이 호출됨 → **클래스를 초기화할 때 꼭 수행되어야 하는 작업이 있는 경우 유용!!!!**

pass by value, pass by reference

- 기본 자료형은 값을 통해 전달, 참조 자료형은 주소값을 통해 전달
- pass by value는 함수에서 값이 변경되어도 외부에 반영되지 않는다. (그 이유는 매개변수로 값으 로 넘길 때 원래 값을 두고, 전달되는 값이 진짜인 것처럼 보이게 한다. 원래 값은 변하지 않는다.)
- pass by reference는 주소값을 인자로 전달받기 때문에 원본 값이 바뀐다.
- 예외 : string
  - String b = “z”;  이런 경우 값이 변경되지 않는데, 그 이유는 b = new Stirng(”z”); 와 같다. 즉 따옴표로 할당하면 객체를 생성한 꼴이므로 **호출된 메소드에서 다른 객체로 처리하면 기존 값은 변경되지 않는다.**

매개변수 지정하는 특이한 방법

```
타입...변수명
```

- ex) int...numbers
- 하나의 메소드에서 한 번만 사용 가능하고, 여러 매개 변수가 있다면 가장 마지막에 선언해야만 한다.